package dk.lockfuglsang.rasmus.util.ui.graph;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;

import javax.swing.JComponent;

import dk.lockfuglsang.rasmus.util.ui.graph.data.GraphData;

public abstract class ChartCanvas extends JComponent {
  /** 5 degrees color increment (hue). 
   * @see #createNewColor()
   * */
  protected static final float COLOR_INCREMENT = 0.1530595238f; // 1/4 + 1/4 * 1/23
  protected static final int LEGEND_BORDER = 5;

  // The actual graph data
  protected final GraphData<String, Number> graphData;
  
  // The title of the graph
  protected String title;
 
  // 
  // Tooltip
  //
  private List<ToolTip> tooltips;
  
  //
  // Autogenerated colors.
  //
  protected Map<String,Color> colors;
  /** Used to generate serie-colors. */
  protected Random rand = new Random(System.currentTimeMillis());
  /** Used to generate serie-colors. */
  protected float lastColorFraction = 0;
  
  // Calculation of min max values
  private boolean dirty;
  protected int minY;
  protected int maxY;
  protected int maxLegendLength;
  protected int maxGridLength;
  
  protected int gridHeight;
  
  // Initialized during paint(Graphics)
  protected Dimension d;
  
  public ChartCanvas(GraphData<String, Number> graphData) {
    this.graphData = graphData;
    this.tooltips = new LinkedList<ToolTip>();
  }
  
  public void setTitle(String title) {
    this.title = title;
  }
  
  public abstract void doPaint(Graphics g);
  
  @Override
  public abstract Dimension getPreferredSize();
  
  @Override
  public final void paint(Graphics g) {
    this.d = getSize();
    calcMinMaxValues(g);
    doPaint(g);
  }
  /** Draws a grid, centered around 0, with the relevant grannulation. */
  protected void drawGrid(Graphics g, int zero, float yScale) {
    // App. 10 grid lines above zero...
    FontMetrics fm = g.getFontMetrics();
    
    int y = zero;
    int deltaY = Math.max((int)(gridHeight*yScale), 1);
    int lines = 0;
    while (y > 0) {
      int x = maxGridLength + 10;
      String sval = "" + (gridHeight*lines);
      g.drawLine(x, y, d.width-1, y);
      int ty = y + fm.getAscent()/2;
      g.drawString(sval, x - fm.stringWidth(sval) - 5, ty);
      y -= deltaY;
      lines++;
    }
    y = zero;
    lines = 0;
    while (y < d.height - fm.getHeight()) {
      int x = maxGridLength + 10;
      String sval = "" + (-gridHeight*lines);
      g.drawLine(x, y, d.width-1, y);
      int ty = y + fm.getAscent()/2;
      g.drawString(sval, x - fm.stringWidth(sval) - 5, ty);
      y += deltaY;
      lines++;
    }
  }
  protected void drawLegends(Graphics g, int barWidth, int barHeight) {
    List<String> labels = graphData.getLabels();
    int n = labels.size();
    int th = g.getFontMetrics().getHeight();
    int bw = Math.min(th, barWidth);
    int bh = Math.min(th, barHeight);
    int lw = maxLegendLength + bw + 2*LEGEND_BORDER;
    int lh = n*th + 2*LEGEND_BORDER;
    int x = d.width - lw - LEGEND_BORDER;
    int y = LEGEND_BORDER;
    // some insets...
    g.setColor(Color.BLACK);
    g.drawRect(x, y, lw, lh);
    g.setXORMode(new Color(0x606060));
    g.setColor(Color.WHITE);
    g.fillRect(x+1, y+1, lw-1, lh-1);
    g.setPaintMode();
    for (int i = 0; i < n; i++) {
      String lbl = labels.get(i);
      g.setColor(getColor(lbl));
      int yi = y + LEGEND_BORDER + ((i+1)*th); // baseline
      g.fillRect(x + LEGEND_BORDER, yi - th + (th-bw)/2 + g.getFontMetrics().getDescent(), bw, bh);
      g.drawString(lbl, x + 2*LEGEND_BORDER + bw, yi);
    }
  }
  protected void addToolTip(Rectangle r, String tooltip) {
    ToolTip toolTip = new ToolTip(r, tooltip);
    tooltips.remove(toolTip);
    tooltips.add(toolTip);
  }
  /** Returns the closest unit of gridline.
   * E.g. if gridHeight is 670, it is rounded to 1000, if it is 45 it is rounded to 100 etc.
   * @param gridHeight
   * @return
   */
  private int getGridHeight(int gridHeight) {
    int grid = 1;
    int gH = gridHeight;
    while (gH > 0) {
      gH /= 10;
      grid *= 10;
    }
    return grid;
  }
  protected boolean isDirty() {
    return dirty;
  }
  protected void setDirty() {
    dirty = true;
  }
  protected Color getColor(String label) {
    Color col = null;
    if (colors != null) {
      col = colors.get(label);
    }
    if (col == null) {
      if (colors == null) {
        colors = new HashMap<String, Color>();
      }
      col = createNewColor();
      colors.put(label, col);
    }
    return col;
  }
  /** Returns a color suitable for graphs. */
  private Color createNewColor() {
    Color col = null;
    lastColorFraction += COLOR_INCREMENT;
    float hue = lastColorFraction; 
    float saturation = 1f;
    float brightness = 1f;
    col = new Color(Color.HSBtoRGB(hue, saturation, brightness));
    return col;
  }
  
  protected void calcMinMaxValues(Graphics g) {
    if (dirty) {
      tooltips.clear();
      minY = 0;
      maxY = 0;
      for (int series = 0; series < graphData.getNumSeries(); series++) {
        for (int x = 0; x < graphData.getNumValues(); x++) {
          int val = graphData.getValueAt(x, series).intValue();
          if (val < minY) {
            minY = val;
          }
          if (val > maxY) {
            maxY = val;
          }
        }
      }
      
      // Calculate gridHeight
      gridHeight = maxY / 10;
      int gh = -minY / 10;
      gridHeight = Math.max(gridHeight, gh);
      // Truncate to even ten or 5...
      gridHeight = getGridHeight(gridHeight);
      
      if (g != null) {
        FontMetrics fm = g.getFontMetrics();
        maxLegendLength = 0;
        for (Iterator<String> it = graphData.getLabels().iterator(); it
            .hasNext();) {
          String lbl = it.next();
          int l = fm.stringWidth(lbl);
          if (l > maxLegendLength) {
            maxLegendLength = l;
          }
        }
        maxGridLength = fm.stringWidth("" + (maxY / gridHeight) * gridHeight);
        int mgl = fm.stringWidth("" + (minY / gridHeight) * gridHeight);
        maxGridLength = Math.max(maxGridLength, mgl);
        dirty = false;
      }
    }
  }
  @Override
  public void setSize(Dimension d) {
    super.setSize(d);
    dirty = true;
  }
  @Override
  public void invalidate() {
    super.invalidate();
    dirty = true;
  }
  
  @Override
  public String getToolTipText(MouseEvent event) {
    int index = tooltips.indexOf(new ToolTipPoint(event.getPoint()));
    if (index != -1) {
      ToolTip tt = tooltips.get(index);
      return tt.getTooltip();
    }
    return null;
  }
  
  /** Encapsulation of tool tip. */
  protected class ToolTip {
    private Rectangle area;
    private String toolTip;
    public ToolTip(Rectangle area, String tooltip) {
      if (area == null) {
        throw new IllegalArgumentException("area cannot be null!");
      }
      if (tooltip == null) {
        throw new IllegalArgumentException("tooltip cannot be null!");
      }
      this.area = area.getBounds();
      this.toolTip = tooltip;
    }
    public String getTooltip() {
      return toolTip;
    }
    @Override
    public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result + ((area == null) ? 0 : area.hashCode());
      result = prime * result + ((toolTip == null) ? 0 : toolTip.hashCode());
      return result;
    }
    /** Returns true if the other object is either a ToolTip with same values, or a Point within the
     * tooltip area.
     */
    @Override
    public boolean equals(Object obj) {
      if (obj instanceof Point) {
        return area.contains((Point)obj);
      } else if (obj instanceof ToolTip) {
        ToolTip other = (ToolTip) obj;
        if (!this.area.equals(other.area)) {
          return false;
        }
        return toolTip.equals(other.getTooltip());
      }
      return false;
    }
  }
  protected class ToolTipPoint extends Point {
    ToolTipPoint(Point p) {
      super(p);
    }
    @Override
    public boolean equals(Object obj) {
      if (obj instanceof ToolTip) {
        return ((ToolTip)obj).equals(this);
      }
      return super.equals(obj);
    }
  }  
}
